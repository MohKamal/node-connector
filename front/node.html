<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Node Editor</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
      }
      svg {
        width: 100vw;
        height: 100vh;
        background-color: #f0f0f0;
        cursor: grab;
      }
      .node {
        cursor: move;
      }
      .port {
        fill: white;
        stroke: black;
        stroke-width: 1px;
        cursor: crosshair;
      }
      .title {
        font-family: sans-serif;
        font-size: 14px;
        text-anchor: middle;
      }
      line.connection {
        stroke: black;
        stroke-width: 2px;
      }

      #toolbar {
        position: absolute;
        top: 10px;
        left: 10px;
        background: rgba(255, 255, 255, 0.9);
        padding: 6px 10px;
        border-radius: 6px;
        box-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
        z-index: 10;
      }

      .palette-node {
        padding: 4px 8px;
        border: 1px solid #ddd;
        border-radius: 4px;
        user-select: none;
      }
      .palette-node:active {
        background: #eee;
      }

      body {
        margin: 0;
        font-family: Arial, sans-serif;
        height: 100vh;
        overflow: hidden;
      }

      .container {
        display: flex;
        height: 100vh;
      }

      .main-area {
        flex: 1;
        background-color: #f4f4f4;
        min-width: 0; /* Prevents overflow issues */
        overflow-y: auto;
        border-right: 1px solid #ccc;
      }

      .sidebar {
        width: 250px;
        background-color: #e0e0e0;
        padding: 10px;
        transition: transform 0.3s ease;
        position: relative;
        overflow-y: auto;
      }

      .sidebar.open {
        transform: translateX(0);
      }

      .sidebar.closed {
        transform: translateX(100%);
      }

      .toggle-btn {
        position: absolute;
        top: 10px;
        left: -40px;
        width: 40px;
        height: 40px;
        background-color: #444;
        color: white;
        border: none;
        cursor: pointer;
        text-align: center;
        line-height: 40px;
        border-radius: 4px 0 0 4px;
      }
    </style>
  </head>
  <body>
    <!-- Main container -->
    <div class="container">
      <!-- Main Content Area -->
      <div id="main-area" class="main-area">
        <!-- Toolbar -->
        <div id="toolbar">
          <label>
            <input type="checkbox" id="toggleGrid" checked />
            Show Grid
          </label>
        </div>

        <!-- Palette Sidebar -->
        <div
          id="palette"
          style="
            position: absolute;
            left: 10px;
            top: 60px;
            background: #fff;
            border: 1px solid #ccc;
            padding: 10px;
            border-radius: 6px;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
            z-index: 10;
          "
        >
          <div
            class="palette-node"
            draggable="true"
            data-type="Start"
            data-icon="üü¢"
            data-inputs="0"
            data-outputs="1"
            style="cursor: grab; margin: 5px"
          >
            Start Node
          </div>
          <div
            class="palette-node"
            draggable="true"
            data-type="Process"
            data-icon="‚öôÔ∏è"
            data-inputs="1"
            data-outputs="1"
            style="cursor: grab; margin: 5px"
          >
            Process Node
          </div>
          <div
            class="palette-node"
            draggable="true"
            data-type="End"
            data-icon="üî¥"
            data-inputs="1"
            data-outputs="0"
            style="cursor: grab; margin: 5px"
          >
            End Node
          </div>
        </div>

        <svg id="canvas"></svg>
      </div>

      <!-- Right Sidebar -->
      <div id="sidebar" class="sidebar open">
        <button id="toggle-btn" class="toggle-btn">Hide ‚ñ∂</button>
        <div class="sidebar-content">
          <h3>Sidebar Elements</h3>
        </div>
      </div>
    </div>

    <script>
      const svg = document.getElementById("canvas");
      let draggedNode = null;
      let nodes = [];
      let offsetX = 0,
        offsetY = 0;
      let scale = 1;

      const viewport = createSVGElement("g", {});
      svg.appendChild(viewport);

      // Create defs for grid pattern
      const defs = createSVGElement("defs", {});
      viewport.appendChild(defs);

      const pattern = createSVGElement("pattern", {
        id: "gridPattern",
        width: 40,
        height: 40,
        patternUnits: "userSpaceOnUse",
      });
      defs.appendChild(pattern);

      const gridRect = createSVGElement("rect", {
        width: 40,
        height: 40,
        fill: "#f9f9f9",
      });
      pattern.appendChild(gridRect);

      const gridLineX = createSVGElement("line", {
        x1: 0,
        y1: 0,
        x2: 40,
        y2: 0,
        stroke: "#ddd",
        "stroke-width": 1,
      });
      pattern.appendChild(gridLineX);

      const gridLineY = createSVGElement("line", {
        x1: 0,
        y1: 0,
        x2: 0,
        y2: 40,
        stroke: "#ddd",
        "stroke-width": 1,
      });
      pattern.appendChild(gridLineY);

      const gridBackground = createSVGElement("rect", {
        width: "100%",
        height: "100%",
        fill: "url(#gridPattern)",
      });
      viewport.appendChild(gridBackground);

      // Toggle grid on/off
      document
        .getElementById("toggleGrid")
        .addEventListener("change", function () {
          gridBackground.style.display = this.checked ? "block" : "none";
        });

      // Utility functions
      function createSVGElement(tag, attrs) {
        const el = document.createElementNS("http://www.w3.org/2000/svg", tag);
        Object.entries(attrs).forEach(([k, v]) => el.setAttribute(k, v));
        return el;
      }

      // Node class
      class Node {
        constructor(x, y, title, icon = "üìÅ", numInputs = 1, numOutputs = 1) {
          this.id = Math.random().toString(36).substr(2, 9);
          this.x = x;
          this.y = y;
          this.title = title;
          this.icon = icon;
          this.radius = 40;
          this.numInputs = numInputs;
          this.numOutputs = numOutputs;
          this.inputs = [];
          this.outputs = [];
          this.connections = []; // { fromPort, toPort }
          this.create();
          this.group.__node__ = this;
        }

        create() {
          // Group element
          this.group = createSVGElement("g", { class: "node" });
          viewport.appendChild(this.group);

          // Title
          this.titleText = createSVGElement("text", {
            x: this.x,
            y: this.y - this.radius - 20,
            class: "title",
          });
          this.titleText.textContent = this.title;
          this.group.appendChild(this.titleText);

          // Circle
          this.circle = createSVGElement("circle", {
            cx: this.x,
            cy: this.y,
            r: this.radius,
            fill: "#ddd",
            stroke: "#333",
            "stroke-width": 2,
          });
          this.group.appendChild(this.circle);

          // Icon inside circle
          this.iconText = createSVGElement("text", {
            x: this.x,
            y: this.y + 10,
            "text-anchor": "middle",
            "font-size": "24px",
          });
          this.iconText.textContent = this.icon;
          this.group.appendChild(this.iconText);

          // Create ports
          const portRadius = 7;
          const verticalSpacing = 25;

          for (let i = 0; i < this.numInputs; i++) {
            const y =
              this.y -
              ((this.numInputs - 1) * verticalSpacing) / 2 +
              i * verticalSpacing;
            const port = createSVGElement("circle", {
              cx: this.x - this.radius - portRadius - 5,
              cy: y,
              r: portRadius,
              class: "port",
              "data-port": `${this.id}-input-${i}`,
            });
            this.inputs.push(port);
            this.group.appendChild(port);

            port.addEventListener("mousedown", (e) => {
              e.stopPropagation();
              startConnection(this, "input", i);
            });
          }

          for (let i = 0; i < this.numOutputs; i++) {
            const y =
              this.y -
              ((this.numOutputs - 1) * verticalSpacing) / 2 +
              i * verticalSpacing;
            const port = createSVGElement("circle", {
              cx: this.x + this.radius + portRadius + 5,
              cy: y,
              r: portRadius,
              class: "port",
              "data-port": `${this.id}-output-${i}`,
            });
            this.outputs.push(port);
            this.group.appendChild(port);

            port.addEventListener("mousedown", (e) => {
              e.stopPropagation();
              startConnection(this, "output", i);
            });
          }

          // Add event listeners
          this.group.addEventListener("mousedown", (e) => {
            draggedNode = this;
            offsetX = e.clientX - this.x;
            offsetY = e.clientY - this.y;
          });
        }

        updatePosition(x, y) {
          this.x = x;
          this.y = y;

          this.titleText.setAttribute("x", this.x);
          this.titleText.setAttribute("y", this.y - this.radius - 20);

          this.circle.setAttribute("cx", this.x);
          this.circle.setAttribute("cy", this.y);

          this.iconText.setAttribute("x", this.x);
          this.iconText.setAttribute("y", this.y + 10);

          const portRadius = 7;
          const verticalSpacing = 25;

          // Update input ports
          for (let i = 0; i < this.inputs.length; i++) {
            const y =
              this.y -
              ((this.numInputs - 1) * verticalSpacing) / 2 +
              i * verticalSpacing;
            this.inputs[i].setAttribute(
              "cx",
              this.x - this.radius - portRadius - 5
            );
            this.inputs[i].setAttribute("cy", y);
          }

          // Update output ports
          for (let i = 0; i < this.outputs.length; i++) {
            const y =
              this.y -
              ((this.numOutputs - 1) * verticalSpacing) / 2 +
              i * verticalSpacing;
            this.outputs[i].setAttribute(
              "cx",
              this.x + this.radius + portRadius + 5
            );
            this.outputs[i].setAttribute("cy", y);
          }

          // Redraw all connections
          const lines = viewport.querySelectorAll("line.connection");
          console.log(lines);
          lines.forEach((line) => {
            viewport.removeChild(line);
          });
          nodes.forEach((node) => {
            node.connections.forEach((conn) => {
              drawConnectionLine(conn.fromPort, conn.toPort);
            });
          });
        }
      }

      // Connections
      let tempLine = null;
      let draggingFrom = null;

      function startConnection(node, type, index) {
        if (tempLine) viewport.removeChild(tempLine);
        const port =
          type === "input" ? node.inputs[index] : node.outputs[index];
        const cx = parseFloat(port.getAttribute("cx"));
        const cy = parseFloat(port.getAttribute("cy"));

        tempLine = createSVGElement("line", {
          x1: cx,
          y1: cy,
          x2: cx,
          y2: cy,
          stroke: "blue",
          "stroke-width": 2,
        });
        viewport.appendChild(tempLine);
        draggingFrom = { node, type, index };
        document.addEventListener("mousemove", drawTempLine);
        document.addEventListener("mouseup", endConnection);
      }

      function drawTempLine(e) {
        if (!tempLine) return;

        const rect = svg.getBoundingClientRect();
        const x = (e.clientX - rect.left - offsetX) / scale;
        const y = (e.clientY - rect.top - offsetY) / scale;

        tempLine.setAttribute("x2", x);
        tempLine.setAttribute("y2", y);
      }

      function endConnection(e) {
        if (!draggingFrom || !tempLine) return;

        const rect = svg.getBoundingClientRect();
        const x = (e.clientX - rect.left - offsetX) / scale;
        const y = (e.clientY - rect.top - offsetY) / scale;

        const target = document.elementFromPoint(e.clientX, e.clientY);
        if (target && target.classList.contains("port")) {
          const fromNode = draggingFrom.node;
          const fromType = draggingFrom.type;
          const fromIndex = draggingFrom.index;
          const fromPort =
            fromType === "input"
              ? fromNode.inputs[fromIndex]
              : fromNode.outputs[fromIndex];

          const toId = target.getAttribute("data-port");
          const [toNodeId, toType, toIndex] = toId.split("-");

          if (
            (fromType === "output" && toType === "input") ||
            (fromType === "input" && toType === "output")
          ) {
            const connection = {
              fromPort,
              toPort: target,
            };

            fromNode.connections.push(connection);

            drawConnectionLine(fromPort, target);
          }
        }
        if (tempLine) {
          viewport.removeChild(tempLine);
          tempLine = null;
        }
        draggingFrom = null;
        document.removeEventListener("mousemove", drawTempLine);
        document.removeEventListener("mouseup", endConnection);
      }

      function removeChildrenByClass(parent, className) {
        const elements = parent.getElementsByClassName(className);
        // Convert HTMLCollection to an array to avoid issues with live collection
        const elementsArray = Array.from(elements);
        for (let i = elementsArray.length - 1; i >= 0; i--) {
          elementsArray[i].parentNode.removeChild(elementsArray[i]);
        }
      }

      function drawConnectionLine(fromPort, toPort) {
        let x1 = parseFloat(fromPort.getAttribute("cx"));
        let y1 = parseFloat(fromPort.getAttribute("cy"));
        let x2 = parseFloat(toPort.getAttribute("cx"));
        let y2 = parseFloat(toPort.getAttribute("cy"));

        let line = createSVGElement("line", {
          x1,
          y1,
          x2,
          y2,
          class: "connection",
        });

        // Prevent duplicates
        Array.from(svg.querySelectorAll("line")).forEach((l) => {
          if (
            l.getAttribute("x1") === x1.toString() &&
            l.getAttribute("y1") === y1.toString() &&
            l.getAttribute("x2") === x2.toString() &&
            l.getAttribute("y2") === y2.toString()
          ) {
            svg.removeChild(l);
          }
        });

        viewport.appendChild(line);

        return line;
      }

      // Mouse events for dragging
      document.addEventListener("mousemove", (e) => {
        if (draggedNode) {
          draggedNode.updatePosition(e.clientX - offsetX, e.clientY - offsetY);
        }
      });

      document.addEventListener("mouseup", () => {
        draggedNode = null;
      });

      // Zoom with mouse wheel
      svg.addEventListener("wheel", (e) => {
        if (!e.ctrlKey) return; // Use Ctrl + Wheel to zoom
        e.preventDefault();

        const zoomFactor = 0.1;
        const mouseX = e.offsetX;
        const mouseY = e.offsetY;

        if (e.deltaY < 0) {
          scale += zoomFactor;
        } else {
          scale -= zoomFactor;
          if (scale < 0.3) scale = 0.3;
        }

        viewport.setAttribute(
          "transform",
          `translate(${offsetX}, ${offsetY}) scale(${scale})`
        );
      });

      // Pan with left mouse click drag
      let isPanning = false;
      let startX, startY;

      svg.addEventListener("mousedown", (e) => {
        if (e.button === 0 && !draggedNode) {
          // Left click and not dragging a node
          isPanning = true;
          startX = e.clientX - offsetX;
          startY = e.clientY - offsetY;
          svg.style.cursor = "grabbing";
        }
      });

      svg.addEventListener("mousemove", (e) => {
        if (isPanning) {
          offsetX = e.clientX - startX;
          offsetY = e.clientY - startY;
          viewport.setAttribute(
            "transform",
            `translate(${offsetX}, ${offsetY}) scale(${scale})`
          );
        }
      });

      svg.addEventListener("mouseup", () => {
        isPanning = false;
        svg.style.cursor = "grab";
      });

      svg.addEventListener("mouseleave", () => {
        isPanning = false;
        svg.style.cursor = "grab";
      });

      // Handle drag start from palette
      document.querySelectorAll(".palette-node").forEach((item) => {
        item.addEventListener("dragstart", function (e) {
          e.dataTransfer.setData(
            "text/plain",
            JSON.stringify({
              type: this.dataset.type,
              icon: this.dataset.icon,
              inputs: parseInt(this.dataset.inputs),
              outputs: parseInt(this.dataset.outputs),
            })
          );
        });
      });

      // Handle drop on canvas
      svg.addEventListener("dragover", function (e) {
        e.preventDefault();
      });
      svg.addEventListener("drop", function (e) {
        e.preventDefault();

        const data = JSON.parse(e.dataTransfer.getData("text/plain"));
        const rect = svg.getBoundingClientRect();
        const x = (e.clientX - rect.left - offsetX) / scale;
        const y = (e.clientY - rect.top - offsetY) / scale;

        new Node(x, y, data.type, data.icon, data.inputs, data.outputs);
      });

      // Remove node on Delete key
      document.addEventListener("keydown", function (e) {
        if (e.key === "Delete" && draggedNode) {
          if (svg.contains(draggedNode.group)) {
            svg.removeChild(draggedNode.group); // Or use viewport.removeChild()
          }
          draggedNode = null;
        }
      });

      // Optional: Right-click to remove
      viewport.addEventListener("contextmenu", function (e) {
        const target = e.target;
        if (target.classList.contains("node")) {
          e.preventDefault();
          const node = target.__node__;
          if (node && confirm("Delete this node?")) {
            svg.removeChild(node.group);
          }
        }
      });

      // Toggle sidebar visibility
      document
        .getElementById("toggle-btn")
        .addEventListener("click", function () {
          const sidebar = document.getElementById("sidebar");
          const btn = document.getElementById("toggle-btn");

          if (sidebar.classList.contains("open")) {
            sidebar.classList.remove("open");
            sidebar.classList.add("closed");
            btn.textContent = "Show ‚óÄ";
          } else {
            sidebar.classList.remove("closed");
            sidebar.classList.add("open");
            btn.textContent = "Hide ‚ñ∂";
          }
        });

      // Example Nodes
      nodes.push(new Node(150, 200, "Start", "üü¢", 0, 2));
      nodes.push(new Node(400, 200, "Process", "‚öôÔ∏è", 2, 2));
      nodes.push(new Node(400, 200, "Process", "‚öôÔ∏è", 5, 4));
      nodes.push(new Node(650, 200, "End", "üî¥", 2, 0));
    </script>
  </body>
</html>
